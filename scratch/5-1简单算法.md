


## 选择排序
基本过程：
* 用i指示每次迭代需要确定最后排序正确的位置
* 用min指向i位置
* 对i位置后的n-i个元素分别与min位置元素比较，过程中，如果元素比min位置元素要小，则min位置改为该位置
* 如果min指示的位置不是i，那么就交换两个位置的值
* 依次类推，直到i到达序列末端前，排序完成
## 选择排序思路图
![选择排序](./选择排序.png)


## 冒泡排序
* 用end指示未排序元素末端
* 从第一个元素到未排序的元素末端（end）之间进行两两相邻交换，如果反序就进行交换，一趟下来，未排序元素末端（end）是排好序的，所以end-1
* 依次类推，直到end指向第一个元素前完全排好序

评价：
* 每次的迭代中，都有可能将元素放到更接近最后排序的位置

冒泡排序的优化： 有时候，当确定了一个位置是有序后，其实序列已经是有序的，但是仍然不知道序列已经有序，所以可以设置一个`flag`用于判断序列是否有序，**如果在比较过程中没有发生交换，就是有序的**。

## 思路图
![冒泡排序思路](./冒泡排序.png)